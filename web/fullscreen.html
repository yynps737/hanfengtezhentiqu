<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨å±3Dè§†å›¾ - ç„Šç¼ç‰¹å¾æå–ç ”å‘å¹³å°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }

        #viewer-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            max-width: 300px;
            z-index: 1000;
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-button {
            padding: 8px 12px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            color: #333;
        }

        .control-button:hover {
            background: #e0e0e0;
            transform: translateX(2px);
        }

        .control-button:active {
            transform: translateX(0);
        }

        .control-button.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        .info-row {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #fff;
            font-weight: bold;
        }

        /* è¿”å›æŒ‰é’® */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            z-index: 1001;
        }

        .back-button:hover {
            background: white;
            transform: translateX(-2px);
        }

        /* åæ ‡è½´æŒ‡ç¤ºå™¨ */
        .axis-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            z-index: 999;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* å·¥å…·æç¤º */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 2000;
        }

        /* å¿«æ·é”®æç¤º */
        .shortcuts {
            position: absolute;
            bottom: 20px;
            right: 350px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            color: white;
        }

        .shortcut-item {
            margin-bottom: 5px;
        }

        .shortcut-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div id="viewer-container"></div>

    <!-- è¿”å›æŒ‰é’® -->
    <button class="back-button" onclick="goBack()">
        â† è¿”å›ä¸»ç•Œé¢
    </button>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <h3>ğŸ® è§†å›¾æ§åˆ¶</h3>

        <div class="control-group">
            <div class="control-label">æ˜¾ç¤ºé€‰é¡¹</div>
            <div class="control-buttons">
                <button class="control-button" id="btnWireframe" onclick="toggleWireframe()">
                    çº¿æ¡†æ¨¡å¼
                </button>
                <button class="control-button active" id="btnGrid" onclick="toggleGrid()">
                    æ˜¾ç¤ºç½‘æ ¼
                </button>
                <button class="control-button active" id="btnAxes" onclick="toggleAxes()">
                    æ˜¾ç¤ºåæ ‡è½´
                </button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">è§†è§’æ§åˆ¶</div>
            <div class="control-buttons">
                <button class="control-button" onclick="resetView()">
                    é‡ç½®è§†è§’
                </button>
                <button class="control-button" onclick="viewFront()">
                    å‰è§†å›¾
                </button>
                <button class="control-button" onclick="viewTop()">
                    é¡¶è§†å›¾
                </button>
                <button class="control-button" onclick="viewSide()">
                    ä¾§è§†å›¾
                </button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">åæ ‡ç³»</div>
            <div class="control-buttons">
                <button class="control-button" onclick="switchAxisMode()">
                    åˆ‡æ¢è½´å‘ <span id="axisMode">XYZ</span>
                </button>
            </div>
        </div>
    </div>

    <!-- ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel" id="infoPanel">
        <div class="info-row">
            <span class="info-label">æ¨¡å‹:</span>
            <span class="info-value" id="modelName">æœªåŠ è½½</span>
        </div>
        <div class="info-row">
            <span class="info-label">é¡¶ç‚¹æ•°:</span>
            <span class="info-value" id="vertexCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">ä¸‰è§’å½¢æ•°:</span>
            <span class="info-value" id="faceCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">ç„Šç¼æ•°:</span>
            <span class="info-value" id="weldCount">0</span>
        </div>
    </div>

    <!-- å¿«æ·é”®æç¤º -->
    <div class="shortcuts">
        <div class="shortcut-item">
            <span class="shortcut-key">å·¦é”®æ‹–åŠ¨</span> æ—‹è½¬
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">å³é”®æ‹–åŠ¨</span> å¹³ç§»
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">æ»šè½®</span> ç¼©æ”¾
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">W</span> çº¿æ¡†åˆ‡æ¢
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">G</span> ç½‘æ ¼åˆ‡æ¢
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">A</span> åæ ‡è½´åˆ‡æ¢
        </div>
        <div class="shortcut-item">
            <span class="shortcut-key">R</span> é‡ç½®è§†è§’
        </div>
    </div>

    <!-- åŠ è½½æç¤º -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>åŠ è½½3Dæ¨¡å‹ä¸­...</p>
    </div>

    <!-- å·¥å…·æç¤º -->
    <div class="tooltip" id="tooltip"></div>

    <!-- åæ ‡è½´æŒ‡ç¤ºå™¨ -->
    <div class="axis-indicator" id="axisIndicator"></div>

    <!-- åŠ è½½Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
        }
    }
    </script>

    <!-- ä¸»åº”ç”¨è„šæœ¬ -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let currentModel = null;
        let isWireframe = false;
        let isGridVisible = true;
        let isAxesVisible = true;
        let axisMode = 0;

        // åˆå§‹åŒ–Three.js
        function init() {
            const container = document.getElementById('viewer-container');

            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);

            // åˆ›å»ºç›¸æœº - Zè½´æœä¸Šé…ç½®
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                10000
            );
            camera.position.set(150, 150, 150);
            camera.up.set(0, 0, 1); // è®¾ç½®Zè½´ä¸ºä¸Šæ–¹å‘

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // åˆ›å»ºæ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 10;
            controls.maxDistance = 1000;

            // æ·»åŠ å…‰æº
            setupLights();

            // æ·»åŠ è¾…åŠ©å¯¹è±¡
            setupHelpers();

            // åŠ è½½æ¨¡å‹æ•°æ®
            loadModelData();

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // éšè—åŠ è½½åŠ¨ç”»
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);
        }

        // è®¾ç½®å…‰æº
        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
            scene.add(hemisphereLight);
        }

        // è®¾ç½®è¾…åŠ©å¯¹è±¡
        function setupHelpers() {
            // ç½‘æ ¼ - åœ¨XYå¹³é¢ï¼ˆZ=0ï¼‰
            const gridHelper = new THREE.GridHelper(200, 20, 0x888888, 0x444444);
            gridHelper.rotateX(Math.PI / 2); // æ—‹è½¬åˆ°XYå¹³é¢
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);

            // åæ ‡è½´
            const axesHelper = new THREE.AxesHelper(50);
            axesHelper.name = 'axesHelper';
            scene.add(axesHelper);
        }

        // æ ¹æ®æ¨¡å‹å¤§å°æ›´æ–°è¾…åŠ©å¯¹è±¡
        function updateHelpers(model) {
            if (!model) return;

            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            // ç§»é™¤æ—§çš„è¾…åŠ©å¯¹è±¡
            const oldGrid = scene.getObjectByName('gridHelper');
            const oldAxes = scene.getObjectByName('axesHelper');

            if (oldGrid) {
                scene.remove(oldGrid);
                oldGrid.geometry?.dispose();
            }
            if (oldAxes) {
                scene.remove(oldAxes);
                oldAxes.geometry?.dispose();
            }

            // åˆ›å»ºæ–°çš„ç½‘æ ¼ - å¤§å°æ ¹æ®æ¨¡å‹è°ƒæ•´
            const gridSize = Math.max(maxDim * 2, 100);
            const gridDivisions = Math.max(20, Math.floor(gridSize / 10));
            const newGrid = new THREE.GridHelper(gridSize, gridDivisions, 0x888888, 0x444444);
            newGrid.rotateX(Math.PI / 2); // æ—‹è½¬åˆ°XYå¹³é¢
            newGrid.name = 'gridHelper';
            newGrid.position.copy(center);
            newGrid.position.z = box.min.z - 1; // æ”¾åœ¨æ¨¡å‹åº•éƒ¨
            newGrid.visible = isGridVisible;
            scene.add(newGrid);

            // åˆ›å»ºæ–°çš„åæ ‡è½´ - å¤§å°æ ¹æ®æ¨¡å‹è°ƒæ•´
            const axesSize = Math.max(maxDim * 0.5, 25);
            const newAxes = new THREE.AxesHelper(axesSize);
            newAxes.name = 'axesHelper';
            newAxes.position.copy(center);
            newAxes.visible = isAxesVisible;
            scene.add(newAxes);
        }

        // åŠ è½½æ¨¡å‹æ•°æ®
        function loadModelData() {
            // ä»localStorageæˆ–sessionStorageè·å–æ¨¡å‹æ•°æ®
            const modelData = sessionStorage.getItem('modelData');

            if (modelData) {
                const data = JSON.parse(modelData);
                displayModel(data);
                updateInfo(data);
            }
        }

        // æ˜¾ç¤ºæ¨¡å‹
        function displayModel(data) {
            if (!data.mesh) return;

            // åˆ›å»ºå‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();

            // è®¾ç½®é¡¶ç‚¹
            const vertices = new Float32Array(data.mesh.vertices);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            // è®¾ç½®é¢
            if (data.mesh.faces) {
                const indices = new Uint32Array(data.mesh.faces);
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            }

            // è®¡ç®—æ³•å‘é‡
            geometry.computeVertexNormals();
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();

            // åˆ›å»ºæè´¨
            const material = new THREE.MeshPhongMaterial({
                color: 0x8888cc,
                specular: 0x222222,
                shininess: 100,
                side: THREE.DoubleSide,
                wireframe: false
            });

            // åˆ›å»ºç½‘æ ¼
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.castShadow = true;
            currentModel.receiveShadow = true;
            scene.add(currentModel);

            // è°ƒæ•´ç›¸æœºå’Œè¾…åŠ©å¯¹è±¡
            fitCameraToObject(currentModel);
            updateHelpers(currentModel);
        }

        // è°ƒæ•´ç›¸æœºè§†è§’
        function fitCameraToObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);

            // å¦‚æœæ¨¡å‹å¤ªå¤§æˆ–å¤ªå°ï¼Œè¿›è¡Œç¼©æ”¾
            let scale = 1;
            const targetSize = 100; // ç›®æ ‡å°ºå¯¸

            if (maxDim > targetSize * 5) {
                // æ¨¡å‹å¤ªå¤§ï¼Œç¼©å°
                scale = targetSize / maxDim;
            } else if (maxDim < targetSize * 0.1) {
                // æ¨¡å‹å¤ªå°ï¼Œæ”¾å¤§
                scale = targetSize / maxDim;
            }

            // åº”ç”¨ç¼©æ”¾
            if (scale !== 1) {
                object.scale.setScalar(scale);
                console.log('æ¨¡å‹ç¼©æ”¾æ¯”ä¾‹:', scale);

                // é‡æ–°è®¡ç®—åŒ…å›´ç›’
                box.setFromObject(object);
                size.copy(box.getSize(new THREE.Vector3()));
                center.copy(box.getCenter(new THREE.Vector3()));
            }

            // å°†æ¨¡å‹ç§»åŠ¨åˆ°åŸç‚¹
            object.position.set(-center.x, -center.y, -center.z);

            // é‡æ–°è®¡ç®—æœ€ç»ˆä½ç½®çš„åŒ…å›´ç›’
            box.setFromObject(object);
            const finalSize = box.getSize(new THREE.Vector3());
            const finalCenter = box.getCenter(new THREE.Vector3());
            const finalMaxDim = Math.max(finalSize.x, finalSize.y, finalSize.z);

            // è®¡ç®—åˆé€‚çš„ç›¸æœºè·ç¦»
            const fov = camera.fov * (Math.PI / 180);
            const distance = finalMaxDim / (2 * Math.tan(fov / 2)) * 1.5;

            camera.position.set(
                finalCenter.x + distance * 0.7,
                finalCenter.y + distance * 0.7,
                finalCenter.z + distance * 0.7
            );
            camera.up.set(0, 0, 1);
            camera.lookAt(finalCenter);

            controls.target.copy(finalCenter);
            controls.maxDistance = distance * 5;
            controls.minDistance = finalMaxDim * 0.1;
            controls.update();
        }

        // æ›´æ–°ä¿¡æ¯é¢æ¿
        function updateInfo(data) {
            document.getElementById('modelName').textContent = data.filename || 'æœªå‘½å';
            document.getElementById('vertexCount').textContent =
                data.mesh ? (data.mesh.vertices.length / 3).toLocaleString() : '0';
            document.getElementById('faceCount').textContent =
                data.mesh ? (data.mesh.faces.length / 3).toLocaleString() : '0';
            document.getElementById('weldCount').textContent =
                data.welds ? data.welds.length : '0';
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                        window.toggleWireframe();
                        break;
                    case 'g':
                        window.toggleGrid();
                        break;
                    case 'a':
                        window.toggleAxes();
                        break;
                    case 'r':
                        window.resetView();
                        break;
                }
            });
        }

        // å…¨å±€å‡½æ•°
        window.toggleWireframe = () => {
            isWireframe = !isWireframe;
            if (currentModel) {
                currentModel.material.wireframe = isWireframe;
            }
            document.getElementById('btnWireframe').classList.toggle('active', isWireframe);
        };

        window.toggleGrid = () => {
            isGridVisible = !isGridVisible;
            const grid = scene.getObjectByName('gridHelper');
            if (grid) grid.visible = isGridVisible;
            document.getElementById('btnGrid').classList.toggle('active', isGridVisible);
        };

        window.toggleAxes = () => {
            isAxesVisible = !isAxesVisible;
            const axes = scene.getObjectByName('axesHelper');
            if (axes) axes.visible = isAxesVisible;
            document.getElementById('btnAxes').classList.toggle('active', isAxesVisible);
        };

        window.resetView = () => {
            if (currentModel) {
                fitCameraToObject(currentModel);
            } else {
                camera.position.set(150, 150, 150);
                camera.up.set(0, 0, 1); // ç¡®ä¿Zè½´æœä¸Š
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        window.viewFront = () => {
            const center = controls.target.clone();
            const distance = camera.position.distanceTo(center);
            camera.position.set(center.x, center.y - distance, center.z);
            camera.up.set(0, 0, 1);
            camera.lookAt(center);
            controls.update();
        };

        window.viewTop = () => {
            const center = controls.target.clone();
            const distance = camera.position.distanceTo(center);
            camera.position.set(center.x, center.y, center.z + distance);
            camera.up.set(0, 1, 0); // é¡¶è§†å›¾æ—¶Yè½´å‘å‰
            camera.lookAt(center);
            controls.update();
        };

        window.viewSide = () => {
            const center = controls.target.clone();
            const distance = camera.position.distanceTo(center);
            camera.position.set(center.x + distance, center.y, center.z);
            camera.up.set(0, 0, 1);
            camera.lookAt(center);
            controls.update();
        };

        window.switchAxisMode = () => {
            // Zè½´æœä¸Šæ¨¡å¼ä¸‹ï¼Œç®€åŒ–ä¸ºåªåˆ‡æ¢è§†è§’
            console.log('åˆ‡æ¢è§†è§’æ¨¡å¼');
            window.resetView();
        };

        window.goBack = () => {
            window.close();
            // å¦‚æœæ— æ³•å…³é—­çª—å£ï¼Œè¿”å›ä¸Šä¸€é¡µ
            if (!window.closed) {
                window.location.href = '/';
            }
        };

        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>